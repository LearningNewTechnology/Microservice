#region using
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
#endregion
namespace Xigadee
{
    /// <summary>
    /// This is the tracker agent used to trace queued and executing jobs.
    /// </summary>
    [DebuggerDisplay("{Type}/{Name}={ProcessSlot}@{Priority}|{Id}")]
    public class TaskTracker
    {
        /// <summary>
        /// This is the priority value for a internal task.
        /// </summary>
        public const int PriorityInternal = -1;

        /// <summary>
        /// This is the default constructor.
        /// </summary>
        /// <param name="type">The tracker type.</param>
        /// <param name="ttl">The allowed time to live.</param>
        public TaskTracker(TaskTrackerType type, TimeSpan? ttl)
        {
            Type = type;
            TTL = ttl??TimeSpan.FromSeconds(30);
        }

        /// <summary>
        /// This is the unique tracking id for the process.
        /// </summary>
        public Guid Id { get; } = Guid.NewGuid();
        /// <summary>
        /// This is the maximum time to live for the process.
        /// </summary>
        public TimeSpan TTL { get; }
        /// <summary>
        /// This is the Microservice tracker type
        /// </summary>
        public TaskTrackerType Type { get; }
        /// <summary>
        /// This is the UTC timestamp for the process.
        /// </summary>
        public DateTime UTCStart { get; } = DateTime.UtcNow;
        /// <summary>
        /// This is the tick count for the process.
        /// </summary>
        public int TickCount { get; } = Environment.TickCount;
        /// <summary>
        /// This is the cancellation token used to signal timeouts or shutdown.
        /// </summary>
        public CancellationTokenSource Cts { get; } = new CancellationTokenSource();

        /// <summary>
        /// This is the command that initiated the request.
        /// </summary>
        public ICommand Callback { get; set; }
        /// <summary>
        /// This is the id that the command has registered the request under.
        /// </summary>
        public string CallbackId { get; set; }
        /// <summary>
        /// Gets or sets the execution time tick count.
        /// </summary>
        public int? ExecuteTickCount { get; set; }
        /// <summary>
        /// Gets the time spent processing.
        /// </summary>
        public TimeSpan? TimeProcessing
        {
            get
            {
                return UTCExecute.HasValue ? DateTime.UtcNow - UTCExecute.Value : default(TimeSpan?);
            }
        }
        /// <summary>
        /// Gets the time remaining until the task will expire.
        /// </summary>
        public TimeSpan? TimeToExpiry
        {
            get
            {
                return ExpireTime.HasValue ? ExpireTime.Value - DateTime.UtcNow : default(TimeSpan?);
            }
        }
        /// <summary>
        /// Gets or sets the current process slot.
        /// </summary>
        public long? ProcessSlot { get; set; }
        /// <summary>
        /// Gets or sets the priority.
        /// </summary>
        public int? Priority { get; set; }

        /// <summary>
        /// This is the friendly name used during statistic debugging.
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The caller name.
        /// </summary>
        public string Caller { get; set; }


        /// <summary>
        /// This boolean property identifies when a task is long running and is used to identify that fact to the Task Manager.
        /// </summary>
        public bool IsLongRunning { get; set; }

        /// <summary>
        /// This boolean property identifies whether the request has been generated by another task for immediate processing.
        /// This type of task will not count as a running task as it has been generated by a task that already has been assigned 
        /// a running slot.
        /// </summary>
        public bool IsInternal { get { return Priority.HasValue && Priority.Value == PriorityInternal; } }
        /// <summary>
        /// This boolean property indicates whether the task has been flagged for cancellation.
        /// </summary>
        public bool IsCancelled { get; set; }
        /// <summary>
        /// Identifies whether the process has been cancelled.
        /// </summary>
        public bool IsKilled { get; set; }

        /// <summary>
        /// This is the functional called which returns the task to be executed when the tracker is scheduled to execute.
        /// </summary>
        public Func<CancellationToken, Task> Execute { get; set; }
        /// <summary>
        /// This action is executed once the task has completed. It passed the original task, a boolean value 
        /// indicating whether the task failed, and any exception that was generated by the failure.
        /// </summary>
        public Action<TaskTracker, bool, Exception> ExecuteComplete { get; set; }

        /// <summary>
        /// Gets or sets the UTC execute time.
        /// </summary>
        public DateTime? UTCExecute { get; set; }
        /// <summary>
        /// Gets or sets the cancelled time.
        /// </summary>
        public DateTime? CancelledTime { get; set; }

        #region HasExpired
        /// <summary>
        /// This boolean value indicates whether the process has expired.
        /// </summary>
        public bool HasExpired
        {
            get
            {
                var time = ExpireTime;
                return time.HasValue && (DateTime.UtcNow > time.Value);
            }
        }
        #endregion
        /// <summary>
        /// Gets the UTC time when the task will expire.
        /// </summary>
        public DateTime? ExpireTime
        {
            get
            {
                return (!UTCExecute.HasValue || IsLongRunning)?default(DateTime?):UTCExecute.Value.Add(TTL);
            }
        }

        #region Cancel()
        /// <summary>
        /// This method is used to cancel the task.
        /// </summary>
        public void Cancel()
        {
            if (IsCancelled)
                return;

            CancelledTime = DateTime.UtcNow;
            IsCancelled = true;

            Cts.Cancel();

            try
            {
                if (Callback != null && !string.IsNullOrEmpty(CallbackId))
                    Callback.TimeoutTaskManager(CallbackId);
            }
            catch (Exception)
            {

            }
        } 
        #endregion

        /// <summary>
        /// This is the task used when the tracker is executed.
        /// </summary>
        public Task ExecuteTask { get; set; }
        /// <summary>
        /// This is the context object that can be used to hold additional data for the context/
        /// </summary>
        public object Context { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether this task has failed.
        /// </summary>
        public bool IsFailure { get; set; }
        /// <summary>
        /// Gets or sets the failure exception.
        /// </summary>
        public Exception FailureException { get; set; }

        #region Debug
        /// <summary>
        /// This is the debug message for the task.
        /// </summary>
        public string Debug
        {
            get
            {
                try
                {
                    var queueTime = StatsCounter.LargeTime((UTCExecute ?? DateTime.UtcNow) - UTCStart);
                    var executeTime = StatsCounter.LargeTime(TimeProcessing, "Never");
                    var expireTime = StatsCounter.LargeTime(TimeToExpiry, "Never");

                    string id = null;
                    string pid = null;

                    switch (Type)
                    {
                        case TaskTrackerType.Notset:
                            return "Not set";
                        case TaskTrackerType.Payload:
                            var payload = Context as TransmissionPayload;
                            id = payload.Message.CorrelationKey;
                            pid = payload.Id.ToString("N").ToUpperInvariant();
                            break;
                        case TaskTrackerType.Schedule:
                            var schedule = Context as Schedule;
                            id = schedule.Id.ToString("N");
                            break;
                        case TaskTrackerType.ListenerPoll:
                        case TaskTrackerType.ListenerClientPoll:
                            id = Id.ToString("N");
                            break;
                        case TaskTrackerType.Overload:
                            id = Id.ToString("N");
                            break;
                    }

                    return string.Format("{10} {0}[{1}] {2} [{3}] Runtime={5} Expires={6} ({7}){8}{9} QueueTime={4} {11}"
                        , Type
                        , Priority
                        , id
                        , Name
                        , queueTime
                        , executeTime
                        , expireTime
                        , Caller
                        , IsLongRunning ? " Long running" : ""
                        , IsCancelled ? (IsKilled?"Killed":"Cancelled") : ""
                        , ProcessSlot
                        , pid
                        );
                }
                catch (Exception ex)
                {
                    return string.Format("Error {0} - {1}", Id, ex.Message);
                }
            }
        }
        #endregion

    }
}
