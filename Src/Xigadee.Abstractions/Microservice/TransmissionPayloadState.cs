using System;
using System.Collections.Generic;
using System.Text;

namespace Xigadee
{
    /// <summary>
    /// This class holds the incoming payload state.
    /// </summary>
    public class TransmissionPayloadState
    {
        /// <summary>
        /// This is the default constructor.
        /// </summary>
        /// <param name="payload">The incoming payload.</param>
        /// <param name="maxTransitCount">The maximum transit count.</param>
        /// <param name="timerStart">The start time.</param>
        public TransmissionPayloadState(TransmissionPayload payload, int maxTransitCount, int timerStart)
        {
            Payload = payload;
            CurrentOptions = payload.Options;
            MaxTransitCount = maxTransitCount;
            TimerStart = timerStart;
        }
        /// <summary>
        /// This is the tickcount of when the incoming payload was first received.
        /// </summary>
        public int TimerStart { get; }

        /// <summary>
        /// This property determines if the incoming request was succesful.
        /// </summary>
        /// <returns></returns>
        public bool IsSuccess()
        {
            return TransmitSuccess || ExecuteSuccess;
        }
        /// <summary>
        /// This signals the payload as complete.
        /// </summary>
        public void Signal()
        {
            //Signal to the underlying listener that the message can be released.
            Payload.Signal(IsSuccess());
        }

        /// <summary>
        /// Set the transmission success. This is true by default. Do not change it.
        /// </summary>
        public bool TransmitSuccess { get; set; } = true;

        /// <summary>
        /// Set the execution success. This is true by default. Do not change it.
        /// </summary>
        public bool ExecuteSuccess { get; set; } = true;

        /// <summary>
        /// This is the incoming payload that needs to be processed.
        /// </summary>
        public TransmissionPayload Payload { get; }

        /// <summary>
        /// These are the response objects generated by the service.
        /// </summary>
        public List<TransmissionPayload> Responses { get; } = new List<TransmissionPayload>();

        /// <summary>
        /// This method validates the incoming payload and ensures that it is not null and that a
        /// message is available.
        /// </summary>
        public void IncomingValidate()
        {
            Payload.Cancel.ThrowIfCancellationRequested();

            //If there is no message then we cannot continue.
            if (Payload == null || Payload.Message == null)
                throw new ArgumentNullException("Payload or Message not present");
        }
        /// <summary>
        /// This is the last exception generated during the execution
        /// </summary>
        public Exception Ex { get; set; }
        /// <summary>
        /// This is set to true if the request generated an exception during exception.
        /// </summary>
        public bool IsFaulted { get { return Ex != null; } }
        /// <summary>
        /// This provides custom routing instructions to the dispatcher.
        /// </summary>
        public ProcessOptions CurrentOptions { get; set; }
        /// <summary>
        /// This is the maximum number of attempts permitted.
        /// </summary>
        public int MaxTransitCount { get; }
        /// <summary>
        /// A boolean property that specifies whether the payload can only be processed externally.
        /// </summary>
        public bool ExternalOnly => (Payload.Options & ProcessOptions.RouteInternal) == 0;
        /// <summary>
        /// A boolean property that specifies if a payload can only be processed internally.
        /// </summary>
        public bool InternalOnly => (Payload.Options & ProcessOptions.RouteExternal) == 0;

        #region IncrementAndVerifyDispatcherTransitCount(TransmissionPayload request.Payload)
        /// <summary>
        /// This method checks that the incoming message has not exceeded the maximum number of hops.
        /// </summary>
        public void IncrementAndVerifyDispatcherTransitCount()
        {
            //Increase the Dispatcher transit count.
            Payload.Message.DispatcherTransitCount = Payload.Message.DispatcherTransitCount + 1;
            //Have we exceeded the transit count for the message.
            if (Payload.Message.DispatcherTransitCount > MaxTransitCount)
                throw new TransitCountExceededException(Payload);
        }
        #endregion
    }

}
